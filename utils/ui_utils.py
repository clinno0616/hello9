# utils/ui_utils.py
import streamlit as st
import torch
from pathlib import Path
from typing import Dict, Any, Tuple

def create_style():
    """
    è¨­ç½®è‡ªå®šç¾© CSS æ¨£å¼
    """
    st.markdown("""
        <style>
        .stTextInput > label {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .stTextArea > label {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .stSlider > label {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .stSelectbox > label {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        .stButton > button {
            width: 100%;
            padding: 0.5rem 1rem;
            font-size: 18px;
        }
        .output-image {
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin: 1rem 0;
        }
        .css-1aehpvj {
            color: #333;
            font-size: 14px;
        }
        .css-1aehpvj code {
            color: #1f1f1f;
            background-color: #f0f2f6;
            padding: 2px 6px;
            border-radius: 4px;
        }
        </style>
    """, unsafe_allow_html=True)

def show_system_info():
    """
    é¡¯ç¤ºç³»çµ±è³‡è¨Š
    """
    with st.sidebar.expander("ç³»çµ±è³‡è¨Š", expanded=False):
        if torch.cuda.is_available():
            gpu_info = torch.cuda.get_device_properties(0)
            memory_allocated = torch.cuda.memory_allocated() / (1024**3)
            memory_total = torch.cuda.get_device_properties(0).total_memory / (1024**3)
            
            st.write(f"ğŸ® GPU: {gpu_info.name}")
            st.write(f"ğŸ’¾ VRAM: {memory_allocated:.2f}GB / {memory_total:.2f}GB")
            st.write(f"ğŸš€ CUDA: {torch.version.cuda}")
        else:
            st.write("âŒ GPU: ä¸å¯ç”¨")
            
        st.write(f"âš¡ PyTorch: {torch.__version__}")

def show_error_message(message: str):
    """
    é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
    """
    st.error(f"âŒ {message}", icon="ğŸš¨")

def show_success_message(message: str):
    """
    é¡¯ç¤ºæˆåŠŸè¨Šæ¯
    """
    st.success(f"âœ… {message}", icon="ğŸ‰")

def show_image_info(params: Dict[str, Any]):
    """
    é¡¯ç¤ºåœ–ç‰‡ç”Ÿæˆåƒæ•¸è³‡è¨Šï¼ŒåŒ…å« LoRA è³‡è¨Š
    """
    with st.expander("ç”Ÿæˆåƒæ•¸", expanded=False):
        # æº–å‚™åŸºæœ¬åƒæ•¸
        formatted_params = {
            "æ¨¡å‹": params.get("model", "unknown"),
            "æç¤ºè©": params.get("prompt", ""),
            "è² é¢æç¤ºè©": params.get("negative_prompt", ""),
            "å¯¬åº¦": params.get("width", 512),
            "é«˜åº¦": params.get("height", 512),
            "CFG Scale": params.get("cfg_scale", 7.0),
            "æ­¥æ•¸": params.get("steps", 20),
            "éš¨æ©Ÿç¨®å­": params.get("seed", -1),
            "æ¡æ¨£æ–¹æ³•": params.get("sampler", "Euler a")
        }
        
        # æ·»åŠ  LoRA è³‡è¨Š
        if "loras" in params and params["loras"]:
            lora_info = {f"LoRA {i+1}": f"{name} (æ¬Šé‡: {weight})" 
                        for i, (name, weight) in enumerate(params["loras"])}
            formatted_params.update(lora_info)
            
        st.json(formatted_params)

def create_prompt_templates() -> str:
    """
    å‰µå»ºæç¤ºè©æ¨¡æ¿é¸æ“‡å™¨
    
    Returns:
        é¸æ“‡çš„æ¨¡æ¿å…§å®¹
    """
    templates = {
        "ç„¡": "",
        "é¢¨æ™¯ç…§": "A beautiful landscape photo, professional photography, 8k, highly detailed, amazing lighting",
        "å‹•æ¼«é¢¨æ ¼": "anime style, highly detailed, vibrant colors, masterpiece, best quality",
        "æ²¹ç•«é¢¨æ ¼": "oil painting style, masterpiece, highly detailed, classical art, museum quality",
        "ç§‘å¹»é¢¨æ ¼": "sci-fi style, futuristic, highly detailed, concept art, intricate details",
        "å¯«å¯¦é¢¨æ ¼": "photorealistic, highly detailed, 8k uhd, professional photography, realistic lighting",
        "æ°´å¢¨ç•«é¢¨æ ¼": "Chinese ink painting, traditional art style, minimalist, elegant, black and white",
        "3D æ¸²æŸ“": "3D render, octane render, highly detailed, professional lighting, 8k resolution",
        "åƒç´ è—è¡“": "pixel art style, retro gaming, 16-bit, crisp pixels, vibrant colors"
    }
    
    selected_template = st.sidebar.selectbox(
        "æç¤ºè©æ¨¡æ¿",
        options=list(templates.keys()),
        index=0
    )
    
    return templates[selected_template]

def create_advanced_settings() -> Dict[str, Any]:
    """
    å‰µå»ºé€²éšè¨­å®šé¢æ¿ï¼ŒåŒ…å« LoRA ç›¸é—œè¨­å®š
    """
    with st.sidebar.expander("é€²éšè¨­å®š", expanded=False):
        # åŸºæœ¬è¨­å®š
        enable_watermark = st.checkbox("æ·»åŠ æµ®æ°´å°", value=False)
        watermark_text = st.text_input("æµ®æ°´å°æ–‡å­—", value="Generated by SD") if enable_watermark else ""
        
        enable_auto_save = st.checkbox("è‡ªå‹•ä¿å­˜", value=True)
        output_dir = st.text_input("ä¿å­˜ç›®éŒ„", value="outputs") if enable_auto_save else "outputs"
        
        # LoRA ç›¸é—œè¨­å®š
        st.subheader("LoRA é€²éšè¨­å®š")
        enable_lora_debug = st.checkbox("é¡¯ç¤º LoRA èª¿è©¦ä¿¡æ¯", value=False)
        
        # é«˜ç´šé‡‡æ¨£è¨­ç½®
        enable_karras_sigmas = st.checkbox("ä½¿ç”¨ Karras èª¿åº¦", value=True)
        use_fp16 = st.checkbox("ä½¿ç”¨åŠç²¾åº¦ (FP16)", value=True)
        
        return {
            "enable_watermark": enable_watermark,
            "watermark_text": watermark_text,
            "enable_auto_save": enable_auto_save,
            "output_dir": output_dir,
            "enable_karras_sigmas": enable_karras_sigmas,
            "use_fp16": use_fp16,
            "enable_lora_debug": enable_lora_debug
        }

def create_help_section():
    """
    å‰µå»ºèªªæ˜æ–‡ä»¶å€æ®µï¼ŒåŒ…å« LoRA ä½¿ç”¨èªªæ˜
    """
    with st.sidebar.expander("ä½¿ç”¨èªªæ˜", expanded=False):
        st.markdown("""
        ### ä½¿ç”¨æ­¥é©Ÿ
        1. é¸æ“‡æƒ³è¦ä½¿ç”¨çš„åŸºç¤æ¨¡å‹
        2. é¸æ“‡ä¸¦è¨­å®š LoRA æ¨¡å‹ï¼ˆå¯é¸ï¼‰
        3. èª¿æ•´ç”Ÿæˆåƒæ•¸
        4. è¼¸å…¥æç¤ºè©
        5. é»æ“Šç”ŸæˆæŒ‰éˆ•
        
        ### LoRA ä½¿ç”¨èªªæ˜
        - LoRAï¼ˆLow-Rank Adaptationï¼‰æ˜¯ä¸€ç¨®æ¨¡å‹å¾®èª¿æŠ€è¡“
        - å¯ä»¥åŒæ™‚ä½¿ç”¨å¤šå€‹ LoRA æ¨¡å‹
        - LoRA æ¬Šé‡ç¯„åœç‚º 0.0-2.0ï¼š
          - 1.0: æ­£å¸¸å¼·åº¦
          - <1.0: é™ä½æ•ˆæœ
          - >1.0: å¢å¼·æ•ˆæœ
        - LoRA æ¨¡å‹è«‹æ”¾ç½®æ–¼ /lora ç›®éŒ„ä¸­
        
        ### åƒæ•¸èªªæ˜
        - **Width/Height**: ç”Ÿæˆåœ–ç‰‡çš„å°ºå¯¸
        - **CFG Scale**: æç¤ºè©å¼•å°å¼·åº¦ï¼Œå€¼è¶Šå¤§è¶Šéµå¾ªæç¤ºè©
        - **Sampling Steps**: ç”Ÿæˆæ­¥æ•¸ï¼Œæ­¥æ•¸è¶Šå¤šå“è³ªè¶Šå¥½
        - **Seed**: éš¨æ©Ÿç¨®å­ï¼Œ-1 ç‚ºéš¨æ©Ÿï¼Œå›ºå®šå€¼å¯é‡ç¾çµæœ
        - **Sampling Method**: æ¡æ¨£æ–¹æ³•ï¼Œå½±éŸ¿ç”Ÿæˆå“è³ªå’Œé€Ÿåº¦
        
        ### æç¤ºè©æŠ€å·§
        1. ä½¿ç”¨è‹±æ–‡æ’°å¯«å¯ä»¥ç²å¾—æ›´å¥½çš„æ•ˆæœ
        2. ç”¨é€—è™Ÿåˆ†éš”ä¸åŒçš„æè¿°å…ƒç´ 
        3. å¯ä»¥ä½¿ç”¨æç¤ºè©æ¨¡æ¿ä½œç‚ºåƒè€ƒ
        4. é‡è¦çš„æè¿°æ”¾åœ¨å‰é¢
        5. å¯ä»¥ä½¿ç”¨é¢¨æ ¼è©å¢å¼·æ•ˆæœ
        
        ### å¸¸ç”¨é¢¨æ ¼è©
        - `masterpiece`: æå‡æ•´é«”å“è³ª
        - `highly detailed`: å¢åŠ ç´°ç¯€
        - `best quality`: æå‡å“è³ª
        - `professional photography`: æ”å½±é¢¨æ ¼
        - `8k`: æé«˜è§£æåº¦
        
        ### è² é¢æç¤ºè©å»ºè­°
        å¸¸ç”¨çš„è² é¢æç¤ºè©ï¼š
        ```
        lowres, bad anatomy, bad hands, text, error, missing fingers, 
        extra digit, fewer digits, cropped, worst quality, low quality, 
        normal quality, jpeg artifacts, signature, watermark, username, 
        blurry, bad feet
        ```
        """)

def get_image_size_warning(width: int, height: int) -> str:
    """
    æ ¹æ“šåœ–ç‰‡å¤§å°è¿”å›è­¦å‘Šè¨Šæ¯
    
    Args:
        width: åœ–ç‰‡å¯¬åº¦
        height: åœ–ç‰‡é«˜åº¦
        
    Returns:
        è­¦å‘Šè¨Šæ¯ï¼Œå¦‚æœæ²’æœ‰å•é¡Œå‰‡è¿”å›ç©ºå­—ç¬¦ä¸²
    """
    total_pixels = width * height
    max_pixels = 1024 * 1024
    
    if total_pixels > max_pixels:
        return "âš ï¸ è­¦å‘Šï¼šåœ–ç‰‡å°ºå¯¸è¼ƒå¤§ï¼Œå¯èƒ½éœ€è¦è¼ƒå¤š VRAM å’Œè¼ƒé•·ç”Ÿæˆæ™‚é–“"
    return ""

def format_time(seconds: float) -> str:
    """
    æ ¼å¼åŒ–æ™‚é–“
    
    Args:
        seconds: ç§’æ•¸
        
    Returns:
        æ ¼å¼åŒ–å¾Œçš„æ™‚é–“å­—ç¬¦ä¸²
    """
    if seconds < 60:
        return f"{seconds:.1f} ç§’"
    minutes = int(seconds / 60)
    seconds = seconds % 60
    return f"{minutes} åˆ† {seconds:.1f} ç§’"